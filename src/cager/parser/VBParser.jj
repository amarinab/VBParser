/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. src/cager/parser\VBParser.jj */
/*@egen*//*
 * Copyright 2005-2006 Paul Cager.
 * 
 * www.paulcager.org
 * 
 * This file is part of cager.parser.
 * 
 * cager.parser is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * cager.parser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with cager.parser; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

/*
**  The TODO list:
**      12. It should handle a ":" appearing at the end of an inline If:
**              If x Then MsgBox "Hello":
**          (a trailing colon is handled in other cases).
**
**  The following have been fixed in version 3
**      1.  "Circle", "Line", "Pset" methods have special syntax. Best approach is
**          probably to skip to the end of line. It may also be best to handle
**          other peculiarities (such as .Print) in the same way.
**      2.  Open strRegFilename For Input Access Read Lock Read Write As #iFile will
**          fail because the token manager will read the "#if" as a conditional compilation.
**          Make it active only at start of line??
**          Also, we currently parse both the "Then" and "Else" halves of conditionally
**          compiled code. Should we only parse one half (but which to choose?)
**      3.  Print "Hello" does not work?
**      4.  "With New X" does not work.
**      5.  "Dim X!" is legal, the "!" indicating a float. It is distinguished from
**          "x = rs!columnName" by devious TokenManager processing
**      6.  Handles "Select Case" statements more gracefully, and generates sensible
**          AST nodes.
**      7.  Handle "Option Private Module"
**      8.  Handle "x = rs![Column Name With Spaces]".
**      9.  Handle "x = Input(1, #1)" and others.
**      10. Handle "Set Property = x".
**      11. Allow "enum" etc. as a name within "Type" declarations.
**      13. Do not add extra ":" to labels or extra "\n" to comments.
**      14. Generate correct parse tree for DotOperand productions, e.g. for "Thing.Func(x)"
**      15. Corrected precedence of unary "Not" operator.
**      16. Included option to process form's "widgets" (turned off by default).
**      17. Created new JJTree node for a ParamSpec, and included accessors for Optional, ByVal,
**          ByRef and ParamArray attributes.
**      18. Removed token definitions such as <OPEN> that are not part of the core language.
**      19. Changed way Statements() production works. It now continually loops calling the
**          Statement() production until it finds tokens indicating an "end-block", e.g. tokens
**          such as "End Sub" or "End If". This avoids a troublesome problem with nested
**          semantic / syntactic lookahead.
**      20. Used parser backtracking to parse irregularly formed statements, such as the
**          "Open" statement. This means I can write productions for the main part
**          of VB without worrying about these anachronisms.
*/


options {                                                                                            
  IGNORE_CASE = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  COMMON_TOKEN_ACTION = true;
  STATIC = false;
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(VBParser)

package cager.parser;

import java.io.*;

public class VBParser/*@bgen(jjtree)*/implements VBParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTVBParserState jjtree = new JJTVBParserState();

/*@egen*/

  final public ASTCompilationUnit CompilationUnit() throws ParseException
  {
      return CompilationUnit(false);
  }

  private void jjtreeOpenNodeScope(Node n)
  {
      ((SimpleNode)n).setFirstToken(getToken(1));
  }


  private void jjtreeCloseNodeScope(Node n)
  {
      // Check that we have consumed at least one token.
      SimpleNode sn = (SimpleNode)n;
      if (sn.getFirstToken() == getToken(1))
      {
          // Not consumed any tokens. Set the first token to null
          // to indicate that the list is empty. Set the last
          // token to the "next" token, so that if we create children
          // within this node, we know where to link in the corresponding
          // tokens.
          sn.setFirstToken(null);
          sn.setLastToken(getToken(1));
      }
      else
      {
          sn.setLastToken(getToken(0));
      }
  }


    /**
    **  do the next tokens indicate the end of a block of
    **  statements (see the "Statements" production for an explanation
    ** of what is going on).
    */

    private boolean isEndBlock()
    {
        switch (getToken(1).kind)
        {
            case ELSEIF:
            case ELSE:
            case LOOP:
            case WEND:
            case NEXT:
            case CASE:
            case EOF:
                return true;
            case END:
                switch (getToken(2).kind)
                {
                    case IF:
                    case WITH:
                    case SELECT:
                    case SUB:
                    case FUNCTION:
                    case PROPERTY:
                        return true;
                }
        }

        return false;
    }

  /**
  **    Used to distinguish "a.b" (object a's method called b) and "a .b" (".b" is a parameter to method a).
  **    See
  */
  private boolean isBinarySuffix()
  {
      Token t = getToken(1);
      int kind = t.kind;

      //System.out.println("isBinarySuffix: " + (t.specialToken == null && (kind == DOT || kind == LPAREN || kind == BANG)));
      //(new Exception()).printStackTrace();

      // It is a binary suffix if it is not preceded by a space, and it is a ".", "(", or "!".

      return t.specialToken == null && (kind == DOT || kind == LPAREN || kind == BANG);
  }


  /**
  **    Some VB contructs have such preculiar syntax that I have decided not to attempt to parse
  **    them. For example the built-in line "method" has the syntax:
  **        Line [Step] (x1, y1) - [Step] (x2, y2), [color], [B][F]
  **    so a call could look like:
  **        Line (X1, Y1)-Step(X2, Y2), Color, BF
  **    See also: SpecialStatement
  */

  static
  private boolean isSpecialMethod(String name)
  {
      name = name.toLowerCase();

      //System.out.println("IsSpecialMethod " + name);

      return name.equals("print") ||
             name.equals("line") ||     // NB: Covers "Line" and "Line Input"
             name.equals("circle") ||
             name.equals("pset") ||
             name.equals("point") ||
             //name.equals("write") ||
             //name.equals("read") ||
             name.equals("scale") ||
             //name.equals("input") ||
             name.equals("seek");
  }

  private boolean isIdentifier(String identifier)
  {
      return isIdentifier(identifier, 1);
  }

  private boolean isIdentifier(String identifier, int token)
  {
      Token t = getToken(token);
      return t.kind == IDENTIFIER && t.image.equalsIgnoreCase(identifier);
  }

  /**
  **    VB provides a Name statement of the form:
  **        Name <File> As <NewName>
  **    This requires special processing, but I have not used the "isSpecialMethod"
  **    trick above, as "Name" is too frequently used as a method / property name.
  **    This method attempts to distinguish the two cases.
  */

  private boolean isNameStatement()
  {
      // Look for <Name> Expr1 <As> Expr2

      if (!isIdentifier("Name"))
        return false;

      // Next token must be preceded by a space, .i.e do not allow
      //    Name.Method As:=12
      if (getToken(2).specialToken == null)
        return false;


      // Look forwards for an "As" token (until end of line).
      for (int i = 2; ; i++)
      {
          Token t = getToken(i);
          if (t.kind == EOF || t.kind == EOL)
            return false;
          if (t.kind == AS)
          {
            // Must be preceded and followed by white space.
            if (t.specialToken != null && getToken(i + 1).specialToken != null)
                return true;
          }
      }
  }


  private void getAnyToken() throws ParseException
  {
      getNextToken();
  }

    private void skipToEndSection()
    {
        while (true)
        {
            Token tok = getToken(1);

            if (tok.kind == EOF)
                break;

            if (tok.kind == END && tok.specialToken == null)
            {
                // Found a line starting with word END. Skip
                // this line as well, and we should be in business.

                  while (getToken(1).kind != EOL)
                  {
                      getNextToken();
                  }

                break;
            }

            getNextToken();
        }
    }

    private void skipToBegin()
    {
        while (true)
        {
            Token tok = getToken(1);

            if (tok.kind == EOF)
                break;

            if (tok.kind == IDENTIFIER && tok.specialToken == null && tok.image.equalsIgnoreCase("BEGIN"))
            {
                // Found a line starting with word BEGIN.

                return;
            }

            getNextToken();
        }
    }


    private boolean attemptErrorRecovery = false;
    public boolean getAttemptErrorRecovery()
    {
        return attemptErrorRecovery;
    }
    public void setAttemptErrorRecovery(boolean val)
    {
        attemptErrorRecovery = val;
    }

    private void handleParseError(ParseException e) throws ParseException
    {
       System.out.println("========================================================================================");
       System.out.println("Error at line " + getToken(1).beginLine + ": " + getToken(1).image );
       System.out.println("Statement not recognised");
       e.printStackTrace();
       error_skiptobefore(EOL);
    }

  public static void main(String args[]) throws Exception {
    VBParser parser;
    SimpleNode node;

    if (args.length == 1) {
      System.out.println("VB Parser:  Reading from file " + args[0] + " . . .");
      try {
        parser = new VBParser(new FileInputStream(args[0]));
      } catch (FileNotFoundException e) {
        System.out.println("VB Parser:  File " + args[0] + " not found.");
        return;
      }
    }
    else
    {
      throw new ParseException("VB Parser:  Usage is \"java VBParser inputfile outputfile\"");
    }

    try {
      parser.setAttemptErrorRecovery(true);
      node = parser.CompilationUnit(false);
      //node = (SimpleNode)(parser.ExprTest());
//      PrintWriter ostr = new PrintWriter(new FileWriter(args[1]));

//    node.jjtAccept(new VBErrHandlerVisitor(), null);

      node.dump(">");

      System.out.println(node.allText(true));
      System.out.println("VBParser:  Parsing completed successfully.");
    } catch (ParseException e) {
      System.out.println("VBParser:  Encountered errors during parse.");
      System.out.println(e);
      e.printStackTrace();
    }
  }

}

PARSER_END(VBParser)

TOKEN_MGR_DECLS :
{
    /**
    **  VB can have line numbers, e.g.
    **      10 Dim X as Integer
    **      20 X = 10
    */
    static String currentLineNumberLabel = "";

    /*
    **  Add any VB line number to each token on that line.
    */
    static void CommonTokenAction(Token t)
    {
        t.currentLineNumberLabel = currentLineNumberLabel;
    }

}

SPECIAL_TOKEN : /* WHITE SPACE */
{
    <SPACE: ( " " | "\t" | "\r" | "\f" | " _\r\n" )+ >
}


<DEFAULT, END_OF_COMMENT> TOKEN :
{
   < EOL: "\n" >
            {
                currentLineNumberLabel = null;
            }
        : START_OF_LINE
}


/*
**  Strip out any labels in the Lexer. This avoids major complications in
**  the parser. For example we would need to cater for statements labels
**  *within* compound statements:
**      For i = 1 To 5
**          Debug.Print i
**      Lbl1: Next i
**  This complicates the grammar and has quite an effect on the lookahead
**  required. Instead we treat labels as a type of statement.
*/
<START_OF_LINE> SPECIAL_TOKEN :
{
   <LEADING_SPACE: ( " " | "\t" | "\r" | "\f" | " _\r\n" )+ >
 | <LINE_NUMBER: (["0"-"9"])+ >
        { currentLineNumberLabel = image.toString(); }
 | <BLANK_LINE: "\n">
}

<START_OF_LINE> TOKEN :
{
   <STATEMENT_LABEL: ["A"-"Z"] (["A"-"Z"] | "_" | ["0"-"9"])+ ":">
        {
            // Exclude the ":" from the label token.
            input_stream.backup(1);
            matchedToken.image = matchedToken.image.substring(0, matchedToken.image.length()-1);
        }
    : DEFAULT
}

 /* Compiler Directives */

<START_OF_LINE> MORE :
{
  < COMP_CONST: "#Const" > : DIRECTIVE_IGNORE
| < COND_IF: "#If" > : DIRECTIVE_IGNORE         // We parse the "Then" part of the conditional code, not the else / ElseIf
| < COND_END_IF: "#End If" >
}


<START_OF_LINE> MORE :
{
  < COND_ELSE: "#Else" > : DIRECTIVE_SKIP       // Ignore the following code
| < COND_ELSEIF: "#ElseIf" > : DIRECTIVE_SKIP
}

<START_OF_LINE> MORE :
{
   < "" > : DEFAULT
}

<DIRECTIVE_IGNORE> SPECIAL_TOKEN :
{
  < "\n" > : START_OF_LINE
}

<DIRECTIVE_IGNORE> MORE :
{
  < ~[] >
}

<DIRECTIVE_SKIP> MORE :
{
  < "#End If" > : DIRECTIVE_IGNORE
| < ~[] >
}




MORE : /* COMMENTS */
{
  "'" : WITHIN_COMMENT
}

<WITHIN_COMMENT> MORE :
{
    // The VB line continuation character ("_") can be used to continue comments
    // over more than one line, as in
    //      '  This is a _
    //         multi-line comment.
    // The following checks for this.

    < (~["\n"])* " _" ("\r")? "\n" >
}

<WITHIN_COMMENT> SPECIAL_TOKEN :
{
    < "\n" >
        {
            // Exclude "\n"
            input_stream.backup(1);
            matchedToken.image = matchedToken.image.substring(0, matchedToken.image.length()-1);
        }
        : END_OF_COMMENT
}


<WITHIN_COMMENT> MORE :
{
    < ~[] >
}


MORE :  // The REM "statement" -- really just a comment
{
    <REM_COMMENT: <REM> <SPACE> > : WITHIN_COMMENT
            // Strictly speaking, does not cater for "REM\n", but we know VB
            // will use \r\n for line terminators. And who uses REMs nowadays...
}

/* Strings */

MORE :
{
  "\"" : WITHIN_STRING
}

<WITHIN_STRING> MORE :
{
  <"\"\""> : WITHIN_STRING
}


<WITHIN_STRING> TOKEN :
{
  < UNTERMINATED_STRING_LITERAL:  "\n" > : DEFAULT
}

<WITHIN_STRING> TOKEN :
{
  < STRING_LITERAL: "\"" > : DEFAULT
}

<WITHIN_STRING> MORE :
{
  < ( ~[] ) >
}



TOKEN : /* RESERVED WORDS AND LITERALS */
{

  < ADDRESSOF: "AddressOf" >
| < AND: "And" >
| < AS: "As" >
| < BYREF: "ByRef" >
| < BYVAL: "ByVal" >
| < CALL: "Call" >
| < CASE: "Case" >
| < CONST: "Const" >
| < DEBUG_PRINT: "Debug.Print" >
| < DEBUG_ASSERT: "Debug.Assert" >
| < DECLARE: "Declare" >
| < DEFMODE: ( "DefBool" | "DefByte" | "DefInt" | "DefLng" | "DefCur" | "DefSng" | "DefDbl" | "DefDec" | "DefDate" | "DefStr" | "DefObj" | "DefVar" ) >
| < DIM: "Dim" >
| < DO: "Do" >
| < EACH: "Each" >
| < ELSE: "else" >
| < ELSEIF: "ElseIf" >
| < END: "End" >
| < ENDPROPERTY: "EndProperty" >
| < ENUM: "Enum" >
| < EQV: "Eqv" >
| < EVENT: "Event">
| < EXIT: "Exit" >
| < FALSE: "false" >
| < FOR: "for" >
| < FRIEND: "Friend" >
| < FUNCTION: "Function" >
| < GET: "Get" >
| < GLOBAL: "Global" >
| < GOTO: "Goto" >
| < IF: "If" >
| < IMP: "Imp" >
| < IMPLEMENTS: "implements" >
| < IN: "In" >
| < IS: "Is" >
| < LIB: "Lib" >
| < LIKE: "Like" >
| < LET: "Let" >
| < LOCK: "Lock" >
| < LOOP: "Loop" >
| < MOD: "Mod" >
| < NEW: "New" >
| < NEXT: "Next" >
| < NOT: "Not" >
| < ON: "On" >
| < OPEN: "Open" >
| < OPTION: "Option" >
| < OPTIONAL: "Optional" >
| < OR: "Or" >
| < PARAMARRAY: "ParamArray" >
| < PRESERVE: "Preserve" >
| < PRIVATE: "private" >
| < PROPERTY: "Property" >
| < PROTECTED: "Protected" >
| < PUBLIC: "Public" >
| < PUT: "Put" >
| < REM: "Rem" >
| < REDIM: "ReDim" >
| < RESUME: "Resume" >
| < SELECT: "Select" >
| < SET: "Set" >
| < SHARED: "Shared" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STEP: "Step" >
| < SUB: "Sub" >
| < THEN: "Then" >
| < TO: "To" >
| < TRUE: "true" >
| < TYPE: "Type" >
| < TYPEOF: "TypeOf" >
| < UNTIL: "Until" >
| < WEND: "Wend" >
| < WHILE: "while" >
| < WITH: "With" >
| < WITHEVENTS: "WithEvents" >
| < XOR: "Xor" >
}


TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < LONG_LITERAL:
        <DECIMAL_LITERAL> "&"
      | <HEX_LITERAL> "&" >
|
  < #DECIMAL_LITERAL: (["0"-"9"])+ >
|
  < #HEX_LITERAL: "&" "H" <HEX_DIGITS> >
|
  < #HEX_DIGITS: (["0"-"9","a"-"f"])+ >
|
  < #OCTAL_LITERAL: "&" ["o"] (["0"-"7"])+ >
|
  < FLOATING_POINT_LITERAL:
      (( <DECIMAL_LITERAL> | <FRACTION> ) (<EXPONENT>)?) ( "#" | "!" | "@")?
  >
|
  < #FRACTION: (<DECIMAL_LITERAL>) "." (["0"-"9"])* | "." (["0"-"9"])+ >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < DATE_LITERAL: "#" ( <DATE_ONLY_LITERAL> ( " " <TIME_ONLY_LITERAL> )? | <TIME_ONLY_LITERAL>  ) "#" >
|
  < #DATE_ONLY_LITERAL: <DECIMAL_LITERAL> "/" <DECIMAL_LITERAL> "/" <DECIMAL_LITERAL> >
|
  < #TIME_ONLY_LITERAL: <DECIMAL_LITERAL> ":" <DECIMAL_LITERAL> ":" <DECIMAL_LITERAL> ( " " )+ ( "AM" | "PM" ) >
}

TOKEN : /* Special token for form items such as
        **      ColDesigner     =   "ServiceForm.frx":007C
        */
{
    < HEX_DISPLACEMENT: ":" <HEX_DIGITS> >
}



 /*
 ** IDENTIFIERS.
 ** Identifiers in VB are complex beasts. As well as the "normal" formats
 ** found in Java, C etc., an identifier may be:
 ** 1.  A normal identifier enclosed in square brackets, e.g.
 **         [Next]
 **     This allows VB to access externally-defined names that might break
 **     VB's own naming rules (typically used for reserved words etc)
 ** 2.  A normal identifier suffixed by a "type-declaration character". These
 **     characters declare the variables type, such as Integer or Long. E.g.
 **         Dim x$
 **     is equivalent to
 **         dim x As String
 **     There is one large complication here. The "!" character is used to
 **     define floats. This conflicts with the use of "!" as a binary operator,
 **     such as
 **         thing = rs!colName
 **     This has been resolved by peeking at the character following the "!". If
 **     it is not a letter or a "[" it is assumed to be a binary operator. In this
 **     case the character is removed from the token and put back on the input stream.
 */
TOKEN :
{
  < IDENTIFIER: ( <PLAIN_IDENTIFIER> | <DELIMITED_IDENTIFIER> ) >
        {
            char ch = matchedToken.image.charAt(matchedToken.image.length() -1);
            if (ch == '!')
            {
                try
                {
                    // Peek at the next character.
                    char nextCh = input_stream.readChar();
                    input_stream.backup(1);

                    if (nextCh == '[' || nextCh == '_' || Character.isLetter(nextCh))
                    {
                        // The "!" was NOT part of the identifier. Rather it was a binary
                        // operator such as x = rs!colName.
                        // Put the "!" back on the input stream
                        input_stream.backup(1);
                        // And remove it from the token
                        matchedToken.image = matchedToken.image.substring(0, matchedToken.image.length()-1);
                    }
                }
                catch (IOException e)
                {
                    throw new Error(e.toString());
                }
            }
            //System.out.println("IDENT: " + matchedToken.image);
        }

|
  < #PLAIN_IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)*  ( <IDENT_SUFFIX> )? >
|
  < #DELIMITED_IDENTIFIER: "[" <PLAIN_IDENTIFIER> "]" >
|
  < #LETTER: [ "A"-"Z", "_", "\u00c7", "\u00c1", "\u00c0", "\u00c3", "\u00c2", "\u00c9", "\u00ca", "\u00cd", "\u00d4", "\u00d3",
"\u00d5", "\u00db", "\u00da", "\u00dc", "\u00d1"] >
|
  < #DIGIT:  [ "0"-"9" ] >
|
  < #IDENT_SUFFIX: [ "%" , "#", "$", "&" , "!" ] >
  //< #IDENT_SUFFIX: [ "%" , "#", "$", "&", "!" ] <SPACE> >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < HASH: "#" >
| < DOT: "." >
| < DOLLAR: "$" >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "<>" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < PERCENT: "%" >
| < BACKSLASH : "\\" >
| < EXPO: "^" >
}

// Prevent lexer-generated errors if unexpected character.
TOKEN :
{
    < ANYTHING_ELSE: ( ~[] ) >
}

/*****************************************
 * THE VB LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

/*
**  NB: There is also a no-argument version of CompilationUnit defined above.
*/

ASTCompilationUnit CompilationUnit(boolean includeProlog)                  :
{/*@bgen(jjtree) CompilationUnit */
  ASTCompilationUnit jjtn000 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompilationUnit */
  try {
/*@egen*/
  [ LOOKAHEAD({isIdentifier("VERSION")}) <IDENTIFIER> Prolog(includeProlog) ]
  ( LOOKAHEAD(4) ModuleLevelStatements() )*
  ( ProcDeclaration() (<EOL>)+ )*
  <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        }
/*@egen*/
        {
          return jjtn000;
        }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

/**
**  VB files start with a prolog (invisible to a user in the IDE). If includeProlog is set to
**  true we will parse it, generating ASTFormItems.
*/


void Prolog(boolean includeProlog) :
{}
{
    LOOKAHEAD( {includeProlog} )
    (
        { skipToBegin(); }

        FormItem()
    )

    |

    (
        { skipToEndSection(); }
    )
}

/*
**  Recursively read the Form items.
*/
void FormItem()           :
{/*@bgen(jjtree) FormItem */
  ASTFormItem jjtn000 = new ASTFormItem(JJTFORMITEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FormItem */
    try {
/*@egen*/
    LOOKAHEAD( <IDENTIFIER>, { getToken(1).image.equalsIgnoreCase("BEGIN") } ) (
        // Cannot use the following - it screws up lookahead somehow...
        //Identifier("BEGIN") TypeName() Name() Eol()

        <IDENTIFIER> [ TypeName() Name() ] Eol()
        ( FormItem() ) *
        <END> Eol()
    )
  | LOOKAHEAD( <IDENTIFIER>, { getToken(1).image.equalsIgnoreCase("BEGINPROPERTY") } ) (
        <IDENTIFIER> PrimaryExpression() [ Guid() ] Eol()
        ( FormItem() ) *
        <ENDPROPERTY> Eol()
    )
  | (
        ( PrimaryExpression() | <TYPE> ) "=" [ "-" | "$" | "^" ] [ Literal() | <IDENTIFIER> ] [ <HEX_DISPLACEMENT> ] Eol()
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void Guid() :
{}
{
    "{" GuidValue() "}"
}


/*
**  Guids have strange values, such as {CB292D44-A0D9-3E99-9C14-43DE7F88A3AD}. We do not attempt to parse
**  all of it.
*/

JAVACODE
void GuidValue()
{
    while (!getToken(1).image.equals("}"))
        getNextToken();
}





// ==============================================================================================================================
/**
**  The following are all statements that can appear at the module level,
**  i.e outside of subs etc.
**  YOU MAY WANT TO SKIP OVER THESE.
*/

void ModuleLevelStatements() :
{}
{
    OptionStatement() Eos()
  | ImplementsDecl() Eos()
  | DefModeStatement()
  | LOOKAHEAD(2) TypeDeclaration() Eos()
  | LOOKAHEAD(2) EventDeclaration() Eos()
  | LOOKAHEAD(2) ConstDeclaration() Eos()
  | LOOKAHEAD(2) EnumDeclaration() Eos()
  | LOOKAHEAD(2) DeclareStatement() Eos()
  | ModLevelDeclaration() Eos()
  | LOOKAHEAD({isIdentifier("Attribute")}) <IDENTIFIER> PrimaryExpression() "=" Expression() ( "," Expression() )* Eos()
  | Eol()
}

void OptionStatement()         :
{/*@bgen(jjtree) Option */
  ASTOption jjtn000 = new ASTOption(JJTOPTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Option */
    try {
/*@egen*/
    <OPTION> ( AnyName() | Literal() | <PRIVATE> )+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ModLevelDeclaration()              :
{/*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declaration */
    try {
/*@egen*/
    ModScopeDecl() VariableDeclaration() ( "," VariableDeclaration() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void EventDeclaration()                   :
{/*@bgen(jjtree) EventDeclaration */
  ASTEventDeclaration jjtn000 = new ASTEventDeclaration(JJTEVENTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EventDeclaration */
    try {
/*@egen*/
    [ ModScopeDecl() ] <EVENT> Name() [ "(" FormalParamList() ")" ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void TypeDeclaration()                  :
{/*@bgen(jjtree) TypeDeclaration */
  ASTTypeDeclaration jjtn000 = new ASTTypeDeclaration(JJTTYPEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeDeclaration */
    try {
/*@egen*/
    [ ModScopeDecl() ] <TYPE> Name() Eos()
        ( LOOKAHEAD(2) [ AnyVariableDeclaration() ] Eos())+
    <END> <TYPE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void EnumDeclaration()                  :
{/*@bgen(jjtree) EnumDeclaration */
  ASTEnumDeclaration jjtn000 = new ASTEnumDeclaration(JJTENUMDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EnumDeclaration */
    try {
/*@egen*/
    [ ModScopeDecl() ] <ENUM> Name() Eos()
        ( [ Name() [ "=" Expression() ] ] Eos())+
    <END> <ENUM>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void DefModeStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <DEFMODE> <IDENTIFIER> "-" <IDENTIFIER> ( "," <IDENTIFIER> "-" <IDENTIFIER> )*/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ImplementsDecl()             :
{/*@bgen(jjtree) Implements */
  ASTImplements jjtn000 = new ASTImplements(JJTIMPLEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Implements */
    try {
/*@egen*/
    <IMPLEMENTS> TypeName()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ModScopeDecl() :
{}
{
    [ <STATIC> ] ( <PUBLIC> | <PRIVATE> | <FRIEND> | <DIM> | <GLOBAL> ) [ <STATIC> ]
}


// ==============================================================================================================================
/**
**  The following are top-level productions for Subs, Functions and Properties
*/

ASTProcDeclaration ProcDeclaration()                  :
{/*@bgen(jjtree) ProcDeclaration */
  ASTProcDeclaration jjtn000 = new ASTProcDeclaration(JJTPROCDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ProcDeclaration */
    try {
/*@egen*/
    (
        LOOKAHEAD(3) SubDeclaration()       { jjtn000.setProcType(SUB); }
      | LOOKAHEAD(3) FunctionDeclaration()  { jjtn000.setProcType(FUNCTION); }
      | LOOKAHEAD(4) PropertyDeclaration()  { jjtn000.setProcType(PROPERTY); }
    )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        }
/*@egen*/

        {
          return jjtn000;
        }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void SubDeclaration() :
{}
{
    [ ModScopeDecl() ] <SUB> Name() [ "(" FormalParamList() ")" ] Eos()
    Statements()
    <END> <SUB>
}

void FunctionDeclaration() :
{}
{
    [ ModScopeDecl() ] <FUNCTION> Name() [ "(" FormalParamList() ")" ] [ <AS> TypeName() [ "(" ")" ] ] Eos()
    Statements()
    <END> <FUNCTION>
}

void PropertyDeclaration() :
{}
{
    LOOKAHEAD(3) PropertyGetDeclaration()
  | LOOKAHEAD(3) PropertyLetDeclaration()
  | LOOKAHEAD(3) PropertySetDeclaration()
}

void PropertyGetDeclaration() :
{}
{
    [ ModScopeDecl() ] <PROPERTY> <GET> Name() [ "(" FormalParamList() ")" ] [ <AS> TypeName() [ "(" ")" ] ] Eos()
    Statements()
    <END> ( <PROPERTY> | <FUNCTION> )
}

void PropertyLetDeclaration() :
{}
{
    [ ModScopeDecl() ] <PROPERTY> <LET> Name() [ "(" FormalParamList() ")" ] Eos()
    Statements()
    <END> <PROPERTY>
}

void PropertySetDeclaration() :
{}
{
    [ ModScopeDecl() ] <PROPERTY> <SET> Name() [ "(" FormalParamList() ")" ] Eos()
    Statements()
    <END> <PROPERTY>
}

void FormalParamList()                  :
{/*@bgen(jjtree) FormalParamList */
  ASTFormalParamList jjtn000 = new ASTFormalParamList(JJTFORMALPARAMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FormalParamList */
    try {
/*@egen*/
    [ ParamSpec() ( "," ParamSpec() )* ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ParamSpec()            :
{/*@bgen(jjtree) ParamSpec */
  ASTParamSpec jjtn000 = new ASTParamSpec(JJTPARAMSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParamSpec */
    try {
/*@egen*/
    [ LOOKAHEAD(1) <OPTIONAL> { jjtn000.setOptional(true); } ]
    ( <BYVAL> { jjtn000.setByVal(true); } | <BYREF> { jjtn000.setByRef(true); } )?
    [ <PARAMARRAY> { jjtn000.setParamArray(true); }]
    AnyName() [ "(" ")" ]
    [ <AS> TypeName() [ "*" Expression() ] ]
    [ "=" Expression() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


// ==============================================================================================================================
/**
**  The following are the productions for the procedure-level statements.
*/

    /*
    **  The Statements production has been changed from
    **      ( Statement() )*
    **  to
    **      ( LOOKAHEAD(0, {!isEndBlock()) Statement() )*
    **  This eliminates problems I had with nested semantic / syntactic lookahead
    **  and also makes it easier to provide error recovery.
    **
    **
    **
    **
    **  Most of VB's syntax is fairly simple, and similar to the syntax for C, Pascal
    **  etc. However there are a few legacy statements that have a more COBOL-like syntax, e.g.:
    **      Open pathname For mode [Access access] [lock] As [#]filenumber [Len=reclength]
    **      object.Line [Step] (x1, y1) [Step] - (x2, y2), [color], [B][F]
    **      Name oldpathname As newpathname
    **  These legacy statements complicate the parsing process. Worse, they complicate
    **  the parsing of the simple statements since complex lookahead is required to
    **  determine that a statement is NOT a legacy statement. For example, compare statements:
    **
    **      SomeObject.SomeFunction("Param1", 2 + 3).Line (SomeOtherFunc(VarName) + 1) * 2
    **      SomeObject.SomeFunction("Param1", 2 + 3).Line (SomeOtherFunc(VarName), 12) - (24, 48)
    **                                                                           ^^^^^^^^^^^^^^^^
    **  The first statement is a simple call of a method called "Line".
    **  The second statement is the legacy "Line" statement.
    **  The parser does not know it is processing a legacy statement until it hits the
    **  comma token as marked by the arrows.
    **
    **  To localise the complexities I use the following scheme:
    **
    **      Save the state of the token stream.
    **      First attempt to parse the statement as a "simple" statement.
    **      If a ParseException occurs
    **          Reset the token stream to its saved value.
    **          Attempt to parse as a Special (legacy) statement.
    **
    **  This is a type of parser backtracking (as opposed to Lookahead backtracking).
    */

ASTStatements Statements()             :
{/*@bgen(jjtree) Statements */
    ASTStatements jjtn000 = new ASTStatements(JJTSTATEMENTS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token startToken;
    int originalArity;
}
{/*@bgen(jjtree) Statements */
    try {
/*@egen*/
    (LOOKAHEAD(0, {!isEndBlock()})

            // Record the position of the last token consumed, and the depth of JJTree's
            // stack, in case we have to backtrack to parse a SpecialStatement.
            { startToken = getToken(0); originalArity = jjtree.nodeArity(); }

            try
            {
                ( Eos() | LOOKAHEAD(0) Statement() Eos() )
            }
            catch (ParseException e)
            {
                try
                {
                    // Attempt special case processing

                    // First reset the tokens back to the start of the statement.
                    jj_ntk = -1;
                    token = startToken;

                    // An ASTStatement node may have been pushed on JJTree's stack (depending
                    // on if the Statement() or Eos() call failed).

                    while (jjtree.nodeArity() > originalArity)
                        jjtree.popNode();

                    SpecialStatement();
                    Eos();
                }
                catch (ParseException failedSpecial)
                {

                  if (!attemptErrorRecovery)
                       throw(e);


                  Token t = getToken(1);

                  handleParseError(failedSpecial);

                  ASTUnrecognisedStatement urs = new ASTUnrecognisedStatement(JJTUNRECOGNISEDSTATEMENT);
                  urs.setFirstToken(t);
                  urs.setLastToken(getToken(0));

                  jjtree.pushNode(urs);
                }
            }

    )*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        }
/*@egen*/

        {
          return jjtn000;
        }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

// A dummy production to force JJTree to generate a ASTUnrecognisedStatement.
void Dummy1()                        :
{/*@bgen(jjtree) UnrecognisedStatement */
  ASTUnrecognisedStatement jjtn000 = new ASTUnrecognisedStatement(JJTUNRECOGNISEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnrecognisedStatement */
    try {
/*@egen*/
    "."/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


ASTStatement Statement() :
{}
{
      (
        LabelStatement()
      | DebugStatement()
      | LOOKAHEAD(IsEndStatement()) EndStatement()
      |/*@bgen(jjtree) Statement */
        {
          ASTStatement jjtn001 = new ASTStatement(JJTSTATEMENT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/ ( LOOKAHEAD({isIdentifier("Attribute")}) <IDENTIFIER> PrimaryExpression() "=" Expression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
      | LOOKAHEAD(2) ProcLevelDeclaration()
      | LOOKAHEAD(2) DeclareStatement()
      | LOOKAHEAD(2) ConstDeclaration()
      | Let()
      | Set()
      | OnErrorStatement()
      | GotoStatement()
      | IfStatement()
      | DoWhile()
      | WhileWend()
      | CallStatement()
      | ExitStatement()
      | LOOKAHEAD(2) ForEachStatement()
      | ForStatement()
      | WithStatement()
      | ResumeStatement()
      | CaseStatement()
      | RedimStatement()
      | PrimaryExprStatement(false)
      )

        {
               ASTStatement s = (ASTStatement)(jjtree.peekNode());
               if (s.begin != null)
               {

                   s.setLineNumber(s.begin.currentLineNumberLabel);
               }

               return s;
       }
}


ASTStatement SpecialStatement() :
{}
{
      (
        LOOKAHEAD( {isNameStatement()} ) NameStatement()
      | OpenStatement()
      | LOOKAHEAD({isIdentifier("Close")}) CloseStatement()
      | LOOKAHEAD({isIdentifier("Line") && isIdentifier("Input", 2)}) LineInputStatement()
      | GetStatement()
      | PutStatement()
      | PrimaryExprStatement(true)
      )

        {
               ASTStatement s = (ASTStatement)(jjtree.peekNode());
               if (s.begin != null)
               {

                   s.setLineNumber(s.begin.currentLineNumberLabel);
               }

               return s;
       }
}

// This production must be specified in this weird format so that
// we do not have to use LOOKAHEAD (which would mess up the semantic
// lookahead in "PrimaryExpression()"
// This seems to be a restriction in JavaCC.

void PrimaryExprStatement(boolean allowSpecialCases) :
{
    Token firstToken = getToken(1);
    boolean isSpecial = false;
}
{
        PrimaryExpression()     { isSpecial = isSpecialMethod(getToken(0).image); }
        (   "="/*@bgen(jjtree) #Assignment( 2) */
                {
                  ASTAssignment jjtn001 = new ASTAssignment(JJTASSIGNMENT);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
          | LOOKAHEAD({allowSpecialCases && isSpecialMethod(getToken(0).image)})/*@bgen(jjtree) #MethodCall( 1) */
                {
                  ASTMethodCall jjtn002 = new ASTMethodCall(JJTMETHODCALL);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                  jjtreeOpenNodeScope(jjtn002);
                }
                try {
/*@egen*/
                skipToEoln()/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002,  1);
                    jjtreeCloseNodeScope(jjtn002);
                  }
                }
/*@egen*/
          |/*@bgen(jjtree) #MethodCall( 2) */
            {
              ASTMethodCall jjtn003 = new ASTMethodCall(JJTMETHODCALL);
              boolean jjtc003 = true;
              jjtree.openNodeScope(jjtn003);
              jjtreeOpenNodeScope(jjtn003);
            }
            try {
/*@egen*/ ArgList()/*@bgen(jjtree)*/
            } catch (Throwable jjte003) {
              if (jjtc003) {
                jjtree.clearNodeScope(jjtn003);
                jjtc003 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte003 instanceof RuntimeException) {
                throw (RuntimeException)jjte003;
              }
              if (jjte003 instanceof ParseException) {
                throw (ParseException)jjte003;
              }
              throw (Error)jjte003;
            } finally {
              if (jjtc003) {
                jjtree.closeNodeScope(jjtn003,  2);
                jjtreeCloseNodeScope(jjtn003);
              }
            }
/*@egen*/
        )

    {
        SimpleNode sn = (SimpleNode)(jjtree.peekNode());
        sn.begin = firstToken;
        sn.end = getToken(0);
    }
}

void LabelStatement()        :
{/*@bgen(jjtree) Label */
  ASTLabel jjtn000 = new ASTLabel(JJTLABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Label */
    try {
/*@egen*/
    <STATEMENT_LABEL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


void DebugStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    ( <DEBUG_PRINT> | <DEBUG_ASSERT> ) skipToEoln()/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void EndStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <END>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

// For LOOKAHEAD only
void IsEndStatement() :
{}
{
    <END> <EOL>
}


void ProcLevelDeclaration()              :
{/*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declaration */
    try {
/*@egen*/
    ProcScopeDecl() AnyVariableDeclaration() ( "," AnyVariableDeclaration() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ProcScopeDecl() :
{}
{
    ( < STATIC > | <DIM> )
}

void VariableDeclaration()          :
{/*@bgen(jjtree) VarDecl */
  ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDecl */
    try {
/*@egen*/
    [ <WITHEVENTS> ] Name() [ "(" [ VariableDimensions() ] ")" ]
        [ <AS> AsTypeClause() ] [ "*" (Literal() | AnyName() ) ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void AnyVariableDeclaration()          :
{/*@bgen(jjtree) VarDecl */
  ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDecl */
    try {
/*@egen*/
    AnyName() [ "(" [ VariableDimensions() ] ")" ]
        [ <AS> AsTypeClause() ] [ "*" (Literal() | AnyName()) ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void AsTypeClause() :
{}
{
    LOOKAHEAD(1)/*@bgen(jjtree) #UnaryOp( 1) */
                 {
                   ASTUnaryOp jjtn001 = new ASTUnaryOp(JJTUNARYOP);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
                   jjtreeOpenNodeScope(jjtn001);
                 }
                 try {
/*@egen*/ ( <NEW> TypeName()/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn001,  1);
                                      jjtc001 = false;
                                      jjtreeCloseNodeScope(jjtn001);
                                    }
/*@egen*/ { jjtn001.op = "New"; } )/*@bgen(jjtree)*/
                 } catch (Throwable jjte001) {
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
                     jjtc001 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte001 instanceof RuntimeException) {
                     throw (RuntimeException)jjte001;
                   }
                   if (jjte001 instanceof ParseException) {
                     throw (ParseException)jjte001;
                   }
                   throw (Error)jjte001;
                 } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001,  1);
                     jjtreeCloseNodeScope(jjtn001);
                   }
                 }
/*@egen*/
                 | TypeName()
}

void VariableDimensions() :
{}
{
    VariableDimension() ( "," VariableDimension() )*
}

void VariableDimension()         :
{/*@bgen(jjtree) VarDim */
  ASTVarDim jjtn000 = new ASTVarDim(JJTVARDIM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDim */
    try {
/*@egen*/
    Expression() [ <TO> Expression() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void RedimStatement()        :
{/*@bgen(jjtree) ReDim */
  ASTReDim jjtn000 = new ASTReDim(JJTREDIM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReDim */
    try {
/*@egen*/
    <REDIM> [ <PRESERVE> ] RedimClause() ( "," RedimClause() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void RedimClause() :
{}
{
    //Name() "(" VariableDimensions() ")"
    PrimaryExpression()
    [ <AS> AsTypeClause() ] [ "*" Literal() ]
}


void DeclareStatement()          :
{/*@bgen(jjtree) Declare */
  ASTDeclare jjtn000 = new ASTDeclare(JJTDECLARE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declare */
    try {
/*@egen*/
    [ ModScopeDecl() ] <DECLARE> ( <SUB> | <FUNCTION> ) Name() <LIB> Literal()
        [ LOOKAHEAD({isIdentifier("Alias")})  <IDENTIFIER> Literal() ]
        [ "(" FormalParamList() ")" ]
        [ <AS> Name() [ "(" ")" ] ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ConstDeclaration()                   :
{/*@bgen(jjtree) ConstDeclaration */
  ASTConstDeclaration jjtn000 = new ASTConstDeclaration(JJTCONSTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstDeclaration */
    try {
/*@egen*/
    [ ModScopeDecl() ] <CONST> ConstSpec() ( "," ConstSpec() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ConstSpec() :
{}
{
    Name() [ <AS> Name() [ "*" (Literal() | AnyName() ) ] ] "=" Expression()
}


void Set()               :
{/*@bgen(jjtree) SetStatement */
  ASTSetStatement jjtn000 = new ASTSetStatement(JJTSETSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SetStatement */
    try {
/*@egen*/
    <SET> PrimaryExpression() "=" Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void Let()             :
{/*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assignment */
    try {
/*@egen*/
    <LET> PrimaryExpression() "=" Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void OnErrorStatement()          :
{/*@bgen(jjtree) OnError */
  ASTOnError jjtn000 = new ASTOnError(JJTONERROR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) OnError */
    try {
/*@egen*/
    //<ON> [ LOOKAHEAD({!isIdentifier("Error")}) <IDENTIFIER> ] <IDENTIFIER> ( <RESUME> [ <NEXT> ] | <GOTO> (Name() | Literal() ) )
    <ON> <IDENTIFIER> [ <IDENTIFIER> ] ( <RESUME> [ <NEXT> ] | <GOTO> (Name() | Literal() ) )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void GotoStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <GOTO> (Name() | <INTEGER_LITERAL>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void IfStatement()              :
{/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
    try {
/*@egen*/
    <IF> Expression() <THEN>
    (
        Eol() MultilineIf()
      | [ ":" ] InlineIf()
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void InlineIf() :
{}
{
    Statement() ( LOOKAHEAD(1) ":" [Statement()] )* [ LOOKAHEAD(1) <ELSE> Statement() ( LOOKAHEAD(1) ":" [Statement()] )* ]
}

void MultilineIf() :
{}
{
        Statements()
    ( <ELSEIF> Expression() <THEN> Eos()
        Statements()
    )*
    [ <ELSE> Eos()
        Statements() ]
    <END> <IF>
}

void DoWhile()                   :
{/*@bgen(jjtree) DoWhileStatement */
  ASTDoWhileStatement jjtn000 = new ASTDoWhileStatement(JJTDOWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DoWhileStatement */
    try {
/*@egen*/
    <DO> [ DoCondition() ] Eos()
        Statements()
    <LOOP> [ DoCondition() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void DoCondition()              :
{/*@bgen(jjtree) DoCondition */
  ASTDoCondition jjtn000 = new ASTDoCondition(JJTDOCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DoCondition */
    try {
/*@egen*/
    (    <WHILE> { jjtn000.conditionWhile = true; }
       | <UNTIL> { jjtn000.conditionWhile = false; }
    ) Condition()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void WhileWend()                     :
{/*@bgen(jjtree) WhileWendStatement */
  ASTWhileWendStatement jjtn000 = new ASTWhileWendStatement(JJTWHILEWENDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileWendStatement */
    try {
/*@egen*/
    <WHILE> Condition() Eos()
        Statements()
    <WEND>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ForEachStatement()                   :
{/*@bgen(jjtree) ForEachStatement */
  ASTForEachStatement jjtn000 = new ASTForEachStatement(JJTFOREACHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForEachStatement */
    try {
/*@egen*/
    <FOR> <EACH> Name() <IN> Expression() Eos()
        Statements()
    <NEXT> [ Name() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ForStatement()               :
{/*@bgen(jjtree) ForStatement */
  ASTForStatement jjtn000 = new ASTForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForStatement */
    try {
/*@egen*/
    <FOR> Name() "=" Expression() <TO> Expression() [ <STEP> Expression() ] Eos()
        Statements()
    <NEXT> [ Name() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/

}

void WithStatement()                 :
{/*@bgen(jjtree) WithStatement */
  ASTWithStatement jjtn000 = new ASTWithStatement(JJTWITHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WithStatement */
    try {
/*@egen*/
    <WITH> Expression()
    // Was "<WITH> PrimaryExpression()" -- PrimaryExpression seems more correct, but does not cater for "With New XX"
        Statements()
    <END> <WITH>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ResumeStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <RESUME> [ <NEXT> | Name() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


/*
** An oddity in the case statement. The documentation says that no statements are
** allowed between "Select Case" and the first "Case" clause. In fact, declarations
** ARE allowed before (any) "Case" clause.
*/

void CaseStatement()                :
{/*@bgen(jjtree) CaseStatement */
  ASTCaseStatement jjtn000 = new ASTCaseStatement(JJTCASESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CaseStatement */
    try {
/*@egen*/
    <SELECT> <CASE> Expression() Eos()
      (
          LOOKAHEAD(2) CaseClause()
      )*
    <END> <SELECT>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void CaseClause() :
{}
{
    ( [ ProcLevelDeclaration() ] Eos() )*
    <CASE> CaseExprList()
    Statements()
}

void CaseExprList() :
{}
{
    CaseExpr() ( "," CaseExpr() ) *
}

void CaseExpr()           :
{/*@bgen(jjtree) CaseExpr */
  ASTCaseExpr jjtn000 = new ASTCaseExpr(JJTCASEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CaseExpr */
    try {
/*@egen*/
    [ <IS> ] ( "<" | ">" | "<=" | ">=" | "=" | "<>" | <LIKE> ) Expression()
  | Expression() [ <TO> Expression() ]
  | <ELSE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void CallStatement()             :
{/*@bgen(jjtree) MethodCall */
  ASTMethodCall jjtn000 = new ASTMethodCall(JJTMETHODCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodCall */
    try {
/*@egen*/
    <CALL> PrimaryExpression() [ "(" ArgList() ")" ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


// TODO Comments. Also need tree to differ for func(x, , y),
// func(x, y) and func(, y, z)

void ArgList()          :
{/*@bgen(jjtree) ArgList */
  ASTArgList jjtn000 = new ASTArgList(JJTARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgList */
    try {
/*@egen*/
//  ( ( "," )* ArgSpec() )*
//  [ ArgSpec() ( "," [ ArgSpec() ] )* ]
    [ LOOKAHEAD(( "," )* ArgSpec()) ( "," )* ArgSpec() ] ( ( "," )+ ArgSpec() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

/*
**  TODO - The [ <TO> Expression() ] clause is used to allow
**      redim Obj.Arr(1 To 4)
**  It might be better to pass in a parameter specifying if we are passing
**  a ReDim clause or a normal Expression.
*/

void ArgSpec()          :
{/*@bgen(jjtree) ArgSpec */
  ASTArgSpec jjtn000 = new ASTArgSpec(JJTARGSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgSpec */
    try {
/*@egen*/
    ( <BYVAL> | <BYREF> )?
    ( LOOKAHEAD(2) NamedArg() | (UnNamedArg() [<TO> Expression()] ) )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/

}

// TODO - can have x = SomeObj.SomeMethod(Sub:=12)
// i.e. a parameter named "Sub" (or indeed, "As", "Byval" etc).
// Need to fix this by using a sematic LA for ":=" and a
// JAVACODE production for NamedArg.
void NamedArg() :
{}
{
    AnyName() ":=" Expression()
}

void UnNamedArg() :
{}
{
    Expression()
}


void ExitStatement()                :
{/*@bgen(jjtree) ExitStatement */
  ASTExitStatement jjtn000 = new ASTExitStatement(JJTEXITSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExitStatement */
    try {
/*@egen*/
    <EXIT> ( <FUNCTION> | <PROPERTY> | <SUB> | <DO> | <FOR> | <WHILE> )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void TypeName()           :
{/*@bgen(jjtree) TypeName */
  ASTTypeName jjtn000 = new ASTTypeName(JJTTYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeName */
    try {
/*@egen*/
    AnyName() [ "." AnyName() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


/**
**   Name() and AnyName()
**   ====================
**
** VB does not allow reserved words (such as "New") to be used
** as identifiers. E.g. these are not valid:
**
**      Dim New As Integer      // INVALID
**      Open = 66               // INVALID
**
** However it does permit the names of member variables/methods
** in expressions etc to be reserved words (presumably this is because
** an object may have been created in a language other than VB, and that
** language may have different keywords). Therefore these are valid:
**
**      X = Obj.Sub.If
**      Public Type YY
**          Sub As Integer
**      End
**
** NB: To confuse things even further, there are some keywords such as
** "Name" which can also be used as the names of variables, e.g.
**
**      Name "Thing.txt" As "Thing.bak"
**      Dim Name as String
**      Name = "X"
**
** The "Name()" production lists all names that can be used directly
** as variable, i.e. that can appear in a "Dim" statement, or can appear
** on the RHS
*/

void Name()       :
{/*@bgen(jjtree) Name */
  ASTName jjtn000 = new ASTName(JJTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Name */
    try {
/*@egen*/
    (
        <IDENTIFIER>
      | <PROPERTY>
      | <STEP>
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    {
        jjtn000.setName(getToken(0).image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void AnyName()                               :
{/*@bgen(jjtree) #Name( jjtree . nodeArity ( ) == 0) */
  ASTName jjtn000 = new ASTName(JJTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Name( jjtree . nodeArity ( ) == 0) */
    try {
/*@egen*/
    (
        Name()
      | <DEFMODE>
      | <ENUM>
      | <EVENT>
      | <GET>
      | <LET>
      | <NEW>
      | <OPEN>
      | <OPTIONAL>
      | <NEXT>
      | <PUT>
      | <SET>
      | <TYPE>
      | <TYPEOF>
      | <END>
      | <ENDPROPERTY>
      | <REM>
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) == 0);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    {
        jjtn000.setName(getToken(0).image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) == 0);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


// Conditions are the same as expressions.
void
Condition() :
{}
{
    Expression()
}


/*
 * Expression syntax follows.
 */

ASTExpression Expression()             :
{/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    ImpExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        }
/*@egen*/
        {
          return jjtn000;
        }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ImpExpression() :
{}
{
    EqvExpression()
    (/*@bgen(jjtree) #BinOp( 2) */
        {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( <IMP> { jjtn001.op = getToken(0).image; } EqvExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
    )*
}

void EqvExpression() :
{}
{
    XorExpression()
    (/*@bgen(jjtree) #BinOp( 2) */
        {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( <EQV> { jjtn001.op = getToken(0).image; } XorExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
    )*
}

void XorExpression() :
{}
{
    OrExpression()
    (/*@bgen(jjtree) #BinOp( 2) */
        {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( <XOR> { jjtn001.op = getToken(0).image; } OrExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
    )*
}

void OrExpression() :
{}
{
    AndExpression()
    (/*@bgen(jjtree) #BinOp( 2) */
        {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( <OR> { jjtn001.op = getToken(0).image; } AndExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
    )*
}

void AndExpression() :
{}
{
    ComparisonOpExpression()
    (/*@bgen(jjtree) #BinOp( 2) */
        {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( <AND> { jjtn001.op = getToken(0).image; } ComparisonOpExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
    )*
}


void ComparisonOpExpression() :
{}
{
    StringConcatExpression()
    (
        LOOKAHEAD(2)/*@bgen(jjtree) #BinOp( 2) */
                     {
                       ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
                       jjtreeOpenNodeScope(jjtn001);
                     }
                     try {
/*@egen*/ ( (  "=" | "<" | ">" | "<=" | ">=" | "<>" | <IS> | <LIKE> )
            { jjtn001.op = getToken(0).image; } StringConcatExpression() )/*@bgen(jjtree)*/
                     } catch (Throwable jjte001) {
                       if (jjtc001) {
                         jjtree.clearNodeScope(jjtn001);
                         jjtc001 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte001 instanceof RuntimeException) {
                         throw (RuntimeException)jjte001;
                       }
                       if (jjte001 instanceof ParseException) {
                         throw (ParseException)jjte001;
                       }
                       throw (Error)jjte001;
                     } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  2);
                         jjtreeCloseNodeScope(jjtn001);
                       }
                     }
/*@egen*/
    )*
}

void StringConcatExpression() :
{}
{
    AdditiveExpression()
    ( LOOKAHEAD(1)/*@bgen(jjtree) #BinOp( 2) */
        {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/      // Tell JavaCC that we are aware of the ambiguity generated by the unary ops.
        ( "&" { jjtn001.op = getToken(0).image; } AdditiveExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
    )*
}


void AdditiveExpression() :
{}
{
    MultiplicativeExpression()
    ( LOOKAHEAD(1)/*@bgen(jjtree) #BinOp( 2) */
        {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/      // Tell JavaCC that we are aware of the ambiguity generated by the unary ops.
        ( ( "+" | "-" ) { jjtn001.op = getToken(0).image; } MultiplicativeExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
    )*
}

void MultiplicativeExpression() :
{}
{
    ExpoExpression()
    ( LOOKAHEAD(1)/*@bgen(jjtree) #BinOp( 2) */
        {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/      // Tell JavaCC that we are aware of the ambiguity generated by the unary ops.
        (( "*" | "/" | "\\" | <MOD> ) { jjtn001.op = getToken(0).image; } ExpoExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
    ) *
}

void ExpoExpression() :
{}
{
    DotOpExpression()
    ( LOOKAHEAD(1)/*@bgen(jjtree) #BinOp( 2) */
        {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( ( "^" ) { jjtn001.op = getToken(0).image; } DotOpExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
    )*
}


void DotOpExpression() :
{}
{
    UnaryOps()
    ( LOOKAHEAD(1)/*@bgen(jjtree) #BinOp( 2) */
      {
        ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
        boolean jjtc001 = true;
        jjtree.openNodeScope(jjtn001);
        jjtreeOpenNodeScope(jjtn001);
      }
      try {
/*@egen*/
      (
          "." { jjtn001.op = getToken(0).image; } DotOperand()
        | "!" { jjtn001.op = getToken(0).image; } BangOperand()
      )/*@bgen(jjtree)*/
      } catch (Throwable jjte001) {
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte001 instanceof RuntimeException) {
          throw (RuntimeException)jjte001;
        }
        if (jjte001 instanceof ParseException) {
          throw (ParseException)jjte001;
        }
        throw (Error)jjte001;
      } finally {
        if (jjtc001) {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtreeCloseNodeScope(jjtn001);
        }
      }
/*@egen*/
     )*
}

/**
**  NB: The argument following a "!" can be ANYTHING -- !X is treated as
**  .Item("X")
*/
JAVACODE
void BangOperand()      
{/*@bgen(jjtree) Name */
 ASTName jjtn000 = new ASTName(JJTNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 try {
/*@egen*/
    if (getToken(1).image.equals("["))
    {
        while (!getToken(0).image.equals("]"))
            getNextToken();
    }
    else if (getToken(1).kind != EOL)
    {
        getAnyToken();
    }
    else
        throw new ParseException("Expected operand after \"!\"");/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
   }
 }
/*@egen*/
}

void DotOperand() :
{}
{
      LOOKAHEAD(2) FuncCall()
    | AnyName()
}

void UnaryOps() :
{}
{
    /*
    ** Unary + and - have the same precedence as "*" etc, so that
    ** "- x ^ y" is interpreted as "- (x^y)".
    */

    /*
    ** Note that a hash sign is permitted before an ExpTerminal to cater for the VB
    ** file IO constructs that expect hash signs, e.g.
    ** x = Input(1, #fileno)
    */

    (/*@bgen(jjtree) #UnaryOp( 1) */
        {
          ASTUnaryOp jjtn001 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( "."           { jjtn001.op = getToken(0).image; } ExpTerminal()               )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
      |/*@bgen(jjtree) #UnaryOp( 1) */
        {
          ASTUnaryOp jjtn002 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
          jjtreeOpenNodeScope(jjtn002);
        }
        try {
/*@egen*/ ( "!"           { jjtn002.op = getToken(0).image; } BangOperand()               )/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  1);
            jjtreeCloseNodeScope(jjtn002);
          }
        }
/*@egen*/
      | LOOKAHEAD(1)/*@bgen(jjtree) #UnaryOp( 1) */
                     {
                       ASTUnaryOp jjtn003 = new ASTUnaryOp(JJTUNARYOP);
                       boolean jjtc003 = true;
                       jjtree.openNodeScope(jjtn003);
                       jjtreeOpenNodeScope(jjtn003);
                     }
                     try {
/*@egen*/ ( <NEW>        { jjtn003.op = getToken(0).image; } UnaryOps()                  )/*@bgen(jjtree)*/
                     } catch (Throwable jjte003) {
                       if (jjtc003) {
                         jjtree.clearNodeScope(jjtn003);
                         jjtc003 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte003 instanceof RuntimeException) {
                         throw (RuntimeException)jjte003;
                       }
                       if (jjte003 instanceof ParseException) {
                         throw (ParseException)jjte003;
                       }
                       throw (Error)jjte003;
                     } finally {
                       if (jjtc003) {
                         jjtree.closeNodeScope(jjtn003,  1);
                         jjtreeCloseNodeScope(jjtn003);
                       }
                     }
/*@egen*/
      |/*@bgen(jjtree) #UnaryOp( 1) */
        {
          ASTUnaryOp jjtn004 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
          jjtreeOpenNodeScope(jjtn004);
        }
        try {
/*@egen*/ ( "+"           { jjtn004.op = getToken(0).image; } ExpoExpression()            )/*@bgen(jjtree)*/
        } catch (Throwable jjte004) {
          if (jjtc004) {
            jjtree.clearNodeScope(jjtn004);
            jjtc004 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte004 instanceof RuntimeException) {
            throw (RuntimeException)jjte004;
          }
          if (jjte004 instanceof ParseException) {
            throw (ParseException)jjte004;
          }
          throw (Error)jjte004;
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004,  1);
            jjtreeCloseNodeScope(jjtn004);
          }
        }
/*@egen*/
      |/*@bgen(jjtree) #UnaryOp( 1) */
        {
          ASTUnaryOp jjtn005 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc005 = true;
          jjtree.openNodeScope(jjtn005);
          jjtreeOpenNodeScope(jjtn005);
        }
        try {
/*@egen*/ ( "-"           { jjtn005.op = getToken(0).image; } ExpoExpression()            )/*@bgen(jjtree)*/
        } catch (Throwable jjte005) {
          if (jjtc005) {
            jjtree.clearNodeScope(jjtn005);
            jjtc005 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte005 instanceof RuntimeException) {
            throw (RuntimeException)jjte005;
          }
          if (jjte005 instanceof ParseException) {
            throw (ParseException)jjte005;
          }
          throw (Error)jjte005;
        } finally {
          if (jjtc005) {
            jjtree.closeNodeScope(jjtn005,  1);
            jjtreeCloseNodeScope(jjtn005);
          }
        }
/*@egen*/
      |/*@bgen(jjtree) #UnaryOp( 1) */
        {
          ASTUnaryOp jjtn006 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
          jjtreeOpenNodeScope(jjtn006);
        }
        try {
/*@egen*/ ( <NOT>         { jjtn006.op = getToken(0).image; } ComparisonOpExpression()    )/*@bgen(jjtree)*/
        } catch (Throwable jjte006) {
          if (jjtc006) {
            jjtree.clearNodeScope(jjtn006);
            jjtc006 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte006 instanceof RuntimeException) {
            throw (RuntimeException)jjte006;
          }
          if (jjte006 instanceof ParseException) {
            throw (ParseException)jjte006;
          }
          throw (Error)jjte006;
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006,  1);
            jjtreeCloseNodeScope(jjtn006);
          }
        }
/*@egen*/
      | LOOKAHEAD(1)/*@bgen(jjtree) #UnaryOp( 1) */
                     {
                       ASTUnaryOp jjtn007 = new ASTUnaryOp(JJTUNARYOP);
                       boolean jjtc007 = true;
                       jjtree.openNodeScope(jjtn007);
                       jjtreeOpenNodeScope(jjtn007);
                     }
                     try {
/*@egen*/ ( <TYPEOF>     { jjtn007.op = getToken(0).image; } UnaryOps()                  )/*@bgen(jjtree)*/
                     } catch (Throwable jjte007) {
                       if (jjtc007) {
                         jjtree.clearNodeScope(jjtn007);
                         jjtc007 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte007 instanceof RuntimeException) {
                         throw (RuntimeException)jjte007;
                       }
                       if (jjte007 instanceof ParseException) {
                         throw (ParseException)jjte007;
                       }
                       throw (Error)jjte007;
                     } finally {
                       if (jjtc007) {
                         jjtree.closeNodeScope(jjtn007,  1);
                         jjtreeCloseNodeScope(jjtn007);
                       }
                     }
/*@egen*/
      |/*@bgen(jjtree) #UnaryOp( 1) */
        {
          ASTUnaryOp jjtn008 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc008 = true;
          jjtree.openNodeScope(jjtn008);
          jjtreeOpenNodeScope(jjtn008);
        }
        try {
/*@egen*/ ( <ADDRESSOF>   { jjtn008.op = getToken(0).image; } UnaryOps()                  )/*@bgen(jjtree)*/
        } catch (Throwable jjte008) {
          if (jjtc008) {
            jjtree.clearNodeScope(jjtn008);
            jjtc008 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte008 instanceof RuntimeException) {
            throw (RuntimeException)jjte008;
          }
          if (jjte008 instanceof ParseException) {
            throw (ParseException)jjte008;
          }
          throw (Error)jjte008;
        } finally {
          if (jjtc008) {
            jjtree.closeNodeScope(jjtn008,  1);
            jjtreeCloseNodeScope(jjtn008);
          }
        }
/*@egen*/
      | [ "#" ] ExpTerminal()
    )
}


void ExpTerminal() :
{}
{
      Literal()
    | "(" Expression() ")"
    | LOOKAHEAD(2) FuncCall()
    | LOOKAHEAD(1) AnyName()
}

void FuncCall() :
{}
{
    AnyName()
    ( LOOKAHEAD(1)/*@bgen(jjtree) #BinOp( 2) */
        {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/           // TODO LOOKAHEAD(1): Why is this ambiguous? Only happens with '( LOOKAHEAD({isIdentifier("Attribute")}) <IDENTIFIER> PrimaryExpression() "=" Expression() ) #Statement'
        ( "(" { jjtn001.op = "()"; } ArgList() ")" )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/
    )+
}

void SpecialFuncCall() :
{}
{
    // TODO
    {System.out.println("SpecialFuncCall");}
    skipToEoln()
}

/**
**  A primary expression is formed from Expression Terminals (literals,
**  function calls, variable names and parenthesized sub-expressions), all
**  potentially linked together by the binary "." and "!" operators.
**  E.g.
**      Obj.SubObj.Method1
**  or
**      Obj.Func("Param1", 4 + 5).Value
**  or plain
**  MethodName
*/
void PrimaryExpression()                    :
{/*@bgen(jjtree) PrimaryExpression */
  ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PrimaryExpression */
      try {
/*@egen*/
      ( "." | "!" ) PrimaryName() PrimarySuffix()
    | Name() PrimarySuffix()/*@bgen(jjtree)*/
      } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          throw (RuntimeException)jjte000;
        }
        if (jjte000 instanceof ParseException) {
          throw (ParseException)jjte000;
        }
        throw (Error)jjte000;
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
          jjtreeCloseNodeScope(jjtn000);
        }
      }
/*@egen*/
}

void PrimarySuffix() :
{}
{
    ( LOOKAHEAD( { isBinarySuffix() } )
        (
            ( "." | "!" ) PrimaryName()
            | "(" ArgList() ")"
        )
    ) *
}

void PrimaryName() :
{}
{
      AnyName()
    | BangOperand()     // TODO: Allows "rs.[a b]"
}



void Literal()          :
{/*@bgen(jjtree) Literal */
  ASTLiteral jjtn000 = new ASTLiteral(JJTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Literal */
  try {
/*@egen*/
  <INTEGER_LITERAL>
|
  <LONG_LITERAL>
|
  <FLOATING_POINT_LITERAL>
|
  <STRING_LITERAL>
|
  <DATE_LITERAL>

|
  "true"
|
  "false"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}


void Arguments()            :
{/*@bgen(jjtree) Arguments */
  ASTArguments jjtn000 = new ASTArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Arguments */
  try {
/*@egen*/
  "(" [ ArgumentList() ] ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ArgumentList() :
{}
{
  Expression() ( "," Expression() )*
}


// ==============================================================================================================================
/**
**  The following are "oddities" in the VB language -- the "Put #" statement etc
*/

void LineInputStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <IDENTIFIER> <IDENTIFIER>  [ LOOKAHEAD(2) "#" ] Expression() "," AnyName()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void GetStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <GET> Expression() "," [ Expression() ]  [ "," Expression() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void PutStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <PUT> Expression() "," [ Expression() ]  [ "," Expression() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void NameStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <IDENTIFIER> Expression() <AS> Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void OpenStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    // Open pathname For mode [Access access] [lock] As [#]filenumber [Len=reclength]

    <OPEN> Expression() <FOR> <IDENTIFIER>
        [ LOOKAHEAD({isIdentifier("Access")}) <IDENTIFIER> <IDENTIFIER> [ <IDENTIFIER> ] ]
        [ LockClause() ]
        <AS> Expression()
        [ LOOKAHEAD({isIdentifier("Len")}) <IDENTIFIER> "=" Expression() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void LockClause() :
{}
{
      <SHARED>
    | <LOCK> <IDENTIFIER> [ <IDENTIFIER> ]
}

void CloseStatement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <IDENTIFIER> [ FileNumberList() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void FileNumberList() :
{}
{
    Expression() ( "," Expression() )*
}


// ==============================================================================================================================



/**
** Consume at least one End-of-line character.
** NB: A java code loop is used here, as a convenient way to prevent
** ambiguities involving end-of-line in other
** statements.
*/
void Eol() :
{}
{
    <EOL>
    {
        while (getToken(1).kind == EOL)
        {
            getNextToken();
        }
    }
}

void Eos() :
{}
{
    Eol() | ":"
}


JAVACODE
void skipToEoln()
{
    while (getToken(1).kind != EOL && getToken(1).kind != COLON)
    {
        getNextToken();
    }
}

JAVACODE
void Identifier(String id)
{
      if (!getToken(1).image.equalsIgnoreCase(id))
        throw generateParseException();

      getNextToken();
}

JAVACODE
void error_skipto(int kind) {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
    // The above loop consumes tokens all the way upto a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
}


// As above, but do not consume the specified token.
JAVACODE
void error_skiptobefore(int kind) {
  while (getToken(1).kind != kind)
    getNextToken();
}

// Test procedure for PrimaryExprStatement
void TestPrimaryExprStatement() :
{}
{
    Statements() <EOF>
        {
            ((SimpleNode)jjtree.peekNode()).dump(">");
        }
}

JAVACODE
void SkipSpecialFunction()
{

}

